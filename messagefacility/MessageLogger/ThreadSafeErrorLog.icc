#error Wrong ThreadSafeErrorLog.icc

#ifndef THREADSAFEERRORLOG_ICC
  #error ThreadSafeErrorLog.icc erroneously included by wrong file
#endif

// ----------------------------------------------------------------------
//
// ThreadSafeErrorLog.icc
//
// ----------------------------------------------------------------------


#ifndef IOSTREAM_INCLUDED
  #include "ZMutility/iostream"
#endif

#ifndef IOMANIP_INCLUDED
  #include "ZMutility/iomanip"
#endif

#include <cstdlib>

namespace mf {


// ----------------------------------------------------------------------
// Birth and Death:
// ----------------------------------------------------------------------

template<class Mutex>
ThreadSafeErrorLog<Mutex>::ThreadSafeErrorLog() : ELtsErrorLog() {}

template<class Mutex>
ThreadSafeErrorLog<Mutex>::ThreadSafeErrorLog( const std::string & pkgName )
                                         : ELtsErrorLog(pkgname) {}

template<class Mutex>
ThreadSafeErrorLog<Mutex>::ThreadSafeErrorLog( const ErrorLog & ee )
                                              : ELtsErrorLog(ee) {}

template<class Mutex>
ThreadSafeErrorLog<Mutex>::ThreadSafeErrorLog(
                const ThreadSafeErrorLog<Mutex> & ee)
                                              : ELtsErrorLog(ee) {}

template<class Mutex> ThreadSafeErrorLog<Mutex>::~ThreadSafeErrorLog() {}


// ----------------------------------------------------------------------
// Message Initiation
// ----------------------------------------------------------------------

template<class Mutex>
ThreadSafeErrorLog<Mutex> &
ThreadSafeErrorLog<Mutex>::operator()
  ( const ELseverityLevel & sev, const std::string & id )
{
  if (msgIsActive) {
    Mutex LOCK;
    dispatch(msg);
  }
  initiateMsg (sev, id);
  return  *this;
}

// ----------------------------------------------------------------------
// Message Continuation:
// ----------------------------------------------------------------------

template <class Mutex, class T>
ThreadSafeErrorLog<Mutex> &
                operator<<( ThreadSafeErrorLog<Mutex> & e, const T & t ) {
  ELtsItem ( e , t );
  return e;
}

// ----------------------------------------------------------------------
// Message Completion:
// ----------------------------------------------------------------------

#ifdef REMOVED
template< class Mutex >
ThreadSafeErrorLog<Mutex> &
ThreadSafeErrorLog<Mutex>::operator<<( void (* f)(ErrorLog &) )  {
        // Note that this uses the SAME SIGNATURE as for ErrorLog.
        // This class won't be invoking f, it will just use it as
        // a trigger to do its own endmsg().
  if (e.discarding) return *this;
  return completeMsg();
}
#endif

template <class Mutex>
ThreadSafeErrorLog<Mutex> & operator<<
                ( ThreadSafeErrorLog<Mutex> & e, void (* f)(ErrorLog &) ) {
    return e.completeMsg();
}

template< class Mutex >
ThreadSafeErrorLog<Mutex> &
ThreadSafeErrorLog<Mutex>::completeMsg() {

  if (e.discarding) return *this;

  if ( msgIsActive )  {

    { Mutex LOCK;       // Will obtain the mutex.  When we leave this
                        // code block, will the mutex will automatically
                        // be destructed, thus released in an exception-safe
                        // manner.
      dispatch ( msg );
    }

    msg.clear();
    msgIsActive = false;
  }
  return  *this;
}  // completeMsg()


template< class Mutex >
ThreadSafeErrorLog<Mutex> &
ThreadSafeErrorLog<Mutex>::operator() ( ErrorObj & msg )  {


  // Unlike the behavior of ErrorLog, this class does not terminate an
  // active message upon receipt of a direct operator() (ErrorObj&).
  // Instead, the newly received ErrorObj goes first, and does not
  // interfere with the one being built up.

  ELextendedID xid = msg.xid;
  bool msgChanged = pokeMsg (msg);
  { Mutex LOCK;
    dispatch (msg);
  }
  if (msgChanged) msg.xid = xid;
  return  *this;

}  // operator()( )

template< class Mutex >
ThreadSafeErrorLog<Mutex> &
ThreadSafeErrorLog<Mutex>::operator() (int nbytes, char * data)  {

  Mutex LOCK;           // Will obtain the mutex.  ELrecv is a complicated
                        // beast, which involves in fact a number of
                        // operator<< to a local ordinary ErrorLog.
                        // So we protect ourselves out here.

  ELrecv ( nbytes, data, module );
  return  *this;

}  // operator() (nbytes, data)


// ----------------------------------------------------------------------


}        // end of namespace mf
